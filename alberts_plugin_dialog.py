# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AlbertsPluginDialog
                                 A QGIS plugin
 Plugin lets you get some informations about destination choices of points.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-06-08
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Albert Kalinowski
        email                : 01159952@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import iface
from qgis.core import QgsWkbTypes
import numpy as np
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'alberts_plugin_dialog_base.ui'))

class AlbertsPluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """
        Konstruktor klasy z parametrem self, którym można poslugiwac się dla zmiennej, funkcji
        w całej klasie. Konstruktor wywoływany jest przy każdym tworzeniu instancji, obiektu klasy.

        Returns
        -------
        None.
        """
        super(AlbertsPluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.area_multiplier = 1
        self.napis = 'm'
        self.pushButton_Warstwa.clicked.connect(self.active_layer)
        self.pushButton_Obiekty.clicked.connect(self.objects)
        self.pushButton_Licz.clicked.connect(self.accepted)
        self.pushButton_Anuluj.clicked.connect(self.canceled)
        self.radioButton_metry.clicked.connect(self.metry)
        self.radioButton_ary.clicked.connect(self.ary)
        self.radioButton_hektary.clicked.connect(self.hektary)
        self.setStyleSheet("""
                           
                        QDialog {
                             background-color: #A2CC31;  
                            
                        }
                     
                           """)
        
    def metry(self):
        """
        Funkcja ustawiająca wartosci dla zmiennych self.napis oraz self.area_multiplier przy każdym
        kliknięciu radioButton_metry.

        Returns
        -------
        None.

        """
        self.area_multiplier = 1
        self.napis = 'm'
    def ary(self):
        """
        Funkcja ustawiająca wartosci dla zmiennych self.napis oraz self.area_multiplier przy każdym
        kliknięciu radioButton_ary.

        Returns
        -------
        None.

        """
        self.area_multiplier = 1/100
        self.napis = 'a'
    def hektary(self):
        """
        Funkcja ustawiająca wartosci dla zmiennych self.napis oraz self.area_multiplier przy każdym
        kliknięciu radioButton_hektary.

        Returns
        -------
        None.

        """
        self.area_multiplier = 1/10000
        self.napis = 'ha'
        
    def active_layer(self):
        """
        Funkcja wyswietlajaca w label_Warstwa nazwę aktywnej warstwy w programie QGIS.

        Returns
        -------
        None.

        """
        active = iface.activeLayer()
        self.label_Warstwa.setText(active.name())
        
    def objects(self):
        """
        Funkcja sprawdzająca typ wybranych przez nas obiektów, licząca ilosc wybranych obiektow oraz
        wypisująca do textEdit współrzędne wybranych obiektow.

        Returns
        -------
        None.

        """
        active = iface.activeLayer()
        selected_objects = active.selectedFeatures()
        
        number_of_objects = len(selected_objects)# active.featureCount() pokazaloby ilosc obiektow na aktywnej warstwie
        
        if number_of_objects == 0:
            message = QtWidgets.QMessageBox()
            message.setIcon(QtWidgets.QMessageBox.Critical)
            message.setText(f'WARNING!\nYou did not choose any object on an active layer')
            message.setWindowTitle(f'Information from Plugin of Albert')
            message.exec_()
        else:
            self.label_Obiekty.setText(f'{number_of_objects}')
        
        counter_Single = 0
        counter_MultiPolygon = 0
        for obj in selected_objects:
            geom = obj.geometry()
            geomSingle = QgsWkbTypes.isSingleType(geom.wkbType())
            if geom.type() == QgsWkbTypes.PointGeometry:
                if geomSingle:
                    x = geom.asPoint()
                    counter_Single += 1
                    self.textEdit.append(f'Point: {x}, \r\n')
                    self.label_Obiekty.setText(f'{number_of_objects}\nChosen points:{counter_Single}')
                else:
                    x = geom.asMultiPoint()
                    self.textEdit.append(f'MultiPoint: {x}, \r\n')
            elif geom.type() == QgsWkbTypes.LineGeometry:
                if geomSingle:
                    x = geom.asPolyline()
                    self.textEdit.append(f'Polyline: {x}, \r\n')
                else:
                    x = geom.asMultiPolyLine()
                    self.textEdit.append(f'MultiPolyLine: {x}, \r\n')
            elif geom.type() == QgsWkbTypes.PolygonGeometry:
                if geomSingle:
                    x = geom.asPolygon()
                    self.textEdit.appned(f'Polygon: {x}, \r\n')
                else:
                    x = geom.asMultiPolygon()
                    counter_MultiPolygon += 1
                    self.textEdit.append(f'MultiPolygon: {x}, \r\n')
                    self.label_Obiekty.setText(f'{number_of_objects}\n Chosen MultiPolygons:{counter_MultiPolygon}')
            else:
                message = QtWidgets.QMessageBox()
                message.setIcon(QtWidgets.QMessageBox.Critical)
                message.setText(f'WARNING!\nFound uknown geometry')
                message.setWindowTitle(f'Information from Plugin of Albert')
                message.exec_()
                
    def canceled(self):
        """
        Funkcja ustawiająca wygląd wtyczki na początkowy, czyszcząca wszystko co było w niej wypisane
        (po każdym kliknięciu pushButton_Anuluj).
        Returns
        -------
        None.

        """
        self.label_Warstwa.setText(f'')
        self.label_Obiekty.setText(f'')
        self.label_Roznica.setText(f'')
        self.label_Pole.setText(f'')
        self.textEdit.setText(f'')
        self.radioButton_metry.setChecked(True)
        
    def accepted(self):
        """
        Funkcja, która dla poszczególnej liczby wybranych punktów wykonuje operacje. Dla dwóch
        punktów będzie to różnica wysokosci między nimi, dla więcej niż dwóch, pole figury.

        Returns
        -------
        None.

        """
        active = iface.activeLayer()
        selected_objects = active.selectedFeatures()
        number_of_objects = len(selected_objects)
        
        if number_of_objects == 0:
            message = QtWidgets.QMessageBox()
            message.setIcon(QtWidgets.QMessageBox.Critical)
            message.setText(f'WARNING!\nUnable computation for any chosen objects.')
            message.setWindowTitle(f'Information from Plugin of Albert')
            message.exec_()
            
        counter_points = 0   
        for obj in selected_objects:
            geom = obj.geometry()
            geomSingle = QgsWkbTypes.isSingleType(geom.wkbType())
            if geom.type() == QgsWkbTypes.PointGeometry:
                counter_points += 1
            else:
                message = QtWidgets.QMessageBox()
                message.setIcon(QtWidgets.QMessageBox.Critical)
                message.setText(f'WARNING!\nUnable computation for chosen objects, other than point ones.')
                message.setWindowTitle(f'Information from Plugin of Albert')
                message.exec_()
                
        if counter_points == 1:
             message = QtWidgets.QMessageBox()
             message.setIcon(QtWidgets.QMessageBox.Critical)
             message.setText(f'WARNING!\nUnable computation for only one chosen point.')
             message.setWindowTitle(f'Information from Plugin of Albert')
             message.exec_()
             
        xyh = []
        if counter_points == 2:
            for i in selected_objects:
                xyh.append([i[1],i[2],i[3]])
            xyh = np.array(xyh)
            roznica_wysokosci = xyh[-1,2] - xyh[0,2]
            iface.messageBar().pushMessage(f'Height difference: {roznica_wysokosci:.3f} m')
            self.label_Roznica.setText(f'Height difference: {roznica_wysokosci:.3f} m')
            
        sigma = 0
        if counter_points > 2:
            for j in selected_objects:
                xyh.append([j[1],j[2],j[3]])
            xyh = np.array(xyh)
            for i in range(len(xyh)):
                sumuj = (xyh[i,0] - xyh[i-2,0]) * xyh[i-1,1]
                sigma += sumuj
                
            pole = abs(sigma / (-2))*self.area_multiplier
            iface.messageBar().pushMessage(f'Area of figure: {pole:.3f} {self.napis}')
            self.label_Pole.setText(f'Area of figure: {pole:.3f} {self.napis}')